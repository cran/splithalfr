<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title>VPT Difference of Means</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">VPT Difference of Means</h1>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(splithalfr)</a></code></pre></div>
<p>This vignette describes a scoring method similar to <a href="https://doi.org/10.1080/026999399379050">Mogg and Bradley (1999)</a>; difference of mean reaction times (RTs) between conditions with probe-at-test and probe-at-control, for correct responses, after removing RTs below 200 ms and above 520 ms, on Visual Probe Task data.</p>
<p><br /></p>
<div id="dataset" class="section level1">
<h1>Dataset</h1>
<p>Load the included VPT dataset and inspect its documentation.</p>
<pre><code>data(&quot;ds_vpt&quot;, package = &quot;splithalfr&quot;)
?ds_vpt</code></pre>
<div id="relevant-variables" class="section level2">
<h2>Relevant variables</h2>
<p>The columns used in this example are:</p>
<ul>
<li>UserID, which identifies participants</li>
<li>block_type, in order to select assessment blocks only</li>
<li>patt, in order to compare trials in which the probe is at the test or at the control stimulus</li>
<li>response, in order to select correct responses only</li>
<li>rt, in order to drop RTs outside of the range [200, 520] and calculate means per level of patt</li>
</ul>
</div>
<div id="preprocessing" class="section level2">
<h2>Preprocessing</h2>
<p>Only select trials from assessment blocks</p>
<pre><code>ds_vpt &lt;- subset(ds_vpt, block_type == &quot;assess&quot;)</code></pre>
<p><br /></p>
</div>
</div>
<div id="scoring-the-vpt" class="section level1">
<h1>Scoring the VPT</h1>
<p>Writing a scoring method for the splithalfr requires implementing two functions; a <strong>sets</strong> function that describes which sets of data should be split into halves and a <strong>score</strong> function that calculates a score.</p>
<div id="defining-the-sets-function" class="section level2">
<h2>Defining the sets function</h2>
<p>The sets function receives data from a single participant and returns a list of datasets for each condition. In this case, we will generate two data frames: one with data from trials with probe-at-test (patt == “yes”) and one with data from trials with probe-at-control (patt == “no”).</p>
<pre><code>vpt_fn_sets &lt;- function (ds) {
  return (list(
    # Probe-at-test
    patt_yes = subset(ds, patt == &quot;yes&quot;),
    # Probe-at-control
    patt_no  = subset(ds, patt == &quot;no&quot;)
  ))
}</code></pre>
</div>
<div id="defining-the-score-function" class="section level2">
<h2>Defining the score function</h2>
<p>The score function receives these two data frames from a single participant and for each:</p>
<ol style="list-style-type: decimal">
<li>selects only correct responses</li>
<li>drops responses with RTs outside of the range [200, 520]</li>
<li>calculates the mean RT of remaining responses</li>
</ol>
<p>Finally, it returns the difference between the two mean RTs.</p>
<pre><code>vpt_fn_score &lt;- function (sets) {
  rt_yes &lt;- subset(sets$patt_yes, response == 1)$rt
  rt_yes &lt;- rt_yes[rt_yes &gt;= 200 &amp; rt_yes &lt;= 520]
  rt_no &lt;- subset(sets$patt_no, response == 1)$rt
  rt_no &lt;- rt_no[rt_no &gt;= 200 &amp; rt_no &lt;= 520]
  return (mean(rt_no) - mean(rt_yes))
}</code></pre>
</div>
<div id="calculating-a-score-without-the-splithalfr" class="section level2">
<h2>Calculating a score without the splithalfr</h2>
<p>By combining the sets and score functions, a score for a single participant can be calculated. For instance, the score of UserID 1 can be calculated via the statement below.</p>
<pre><code>vpt_fn_score(vpt_fn_sets(subset(ds_vpt, UserID == 1)))</code></pre>
</div>
<div id="calculating-scores-with-the-splithalfr" class="section level2">
<h2>Calculating scores with the splithalfr</h2>
<p>To calculate scores for each participant, call sh_apply with four arguments:</p>
<ol style="list-style-type: decimal">
<li>the dataset</li>
<li>the column that identifies participants in the dataset</li>
<li>the sets function</li>
<li>the score function</li>
</ol>
<p>The sh_apply function will return a data frame with one row per participant, and two columns: one that identifies participants (“UserID” in this example) and a column “score”, that contains the output of the score function.</p>
<pre><code>vpt_scores &lt;- sh_apply(ds_vpt, &quot;UserID&quot;, vpt_fn_sets, vpt_fn_score)</code></pre>
</div>
<div id="checking-scores" class="section level2">
<h2>Checking scores</h2>
<p>It is recommended to check your scoring method by calculating the score of a representative participant via a different approach. For splithalfr tests, the author has done so via Excel. Note that in the example dataset, some participants (such as UserID 28) did not have any correct responses in the patt == yes condition with RTs within the range [200, 520]. For these participants, a score could not be calculated.</p>
<p><br /></p>
</div>
</div>
<div id="estimating-split-half-reliability" class="section level1">
<h1>Estimating split-half reliability</h1>
<div id="generating-split-scores" class="section level2">
<h2>Generating split scores</h2>
<p>To calculate split-half scores for each participant, call sh_apply with an additional split_count argument, which specifies how many splits should be calculated. For each participant and split, the splithalfr will randomly divide the dataset of each element of sets into two halves that differ at most by one in size. When called with a split_count argument that is higher than zero, sh_apply returns a data frame with the following columns:</p>
<ul>
<li>UserID, which identifies participants</li>
<li>split, which counts splits</li>
<li>score_1, and score_2, which are the scores calculated for each of the split datasets</li>
</ul>
<p>Since for some participants a score could not be calculated, the split scores are missing for these participants as well.</p>
<pre><code>vpt_splits &lt;- sh_apply(ds_vpt, &quot;UserID&quot;, vpt_fn_sets, vpt_fn_score, 1000)</code></pre>
</div>
<div id="estimating-reliability-averaged-over-splits" class="section level2">
<h2>Estimating reliability averaged over splits</h2>
<p>Next, the output of sh_apply can be analyzed in order to estimate reliability. By default, functions are provided that automatically calculate mean Spearman-Brown (mean_sb_by_split) and Flanagan-Rulon (mean_fr_by_split) coefficients. If any missing values were encountered in the data provided to these functions, they give a warning, and then pairwise remove the missing data before calculating reliability.</p>
<pre><code># Spearman-Brown
mean_sb_by_split(vpt_splits)</code></pre>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
